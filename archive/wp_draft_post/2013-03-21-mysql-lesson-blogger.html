---
layout: post
status: publish
published: true
title: 'Урок 2: Основы MySQL для блогера'
author:
  display_name: SlowProg
  login: seoadmin
  email: paperplanesu@rambler.ru
  url: http://paperplane.su
author_login: seoadmin
author_email: paperplanesu@rambler.ru
author_url: http://paperplane.su
wordpress_id: 1052
wordpress_url: http://paperplane.su/?p=1052
date: '2013-03-21 15:12:24 +0400'
date_gmt: '2013-03-21 11:12:24 +0400'
categories:
- Кодинг для блогеров
tags:
- PHP
- основы
- mysql
comments:
- id: 141648
  author: Serpent
  author_email: rubtsov-gel@yandex.ru
  author_url: http://rubtsow.ru
  date: '2013-03-21 16:10:17 +0400'
  date_gmt: '2013-03-21 12:10:17 +0400'
  content: "+1 Полезно знать всем."
- id: 141670
  author: 'Урок 2: Основы MySQL для блогера | На уровень выше'
  author_email: ''
  author_url: http://vvh.su/uroki/urok-2-osnovy-mysql-dlya-blogera.html
  date: '2013-03-21 19:42:24 +0400'
  date_gmt: '2013-03-21 15:42:24 +0400'
  content: "[...] Урок 2: Основы MySQL для блогера это пост с SEO блога разработки
    и дазайна: SEOлётик [...]"
- id: 141768
  author: Daria
  author_email: aureadaria@gmail.com
  author_url: http://www.control-point.ru/
  date: '2013-03-22 16:52:27 +0400'
  date_gmt: '2013-03-22 12:52:27 +0400'
  content: Здравствуйте! Не люблю работать вслепую, особенно когда заменяешь плагин
    кодом, но приходилось - знаний маловато. Очень рада этому циклу статей. Буду читать
    и разбираться. Материал для меня непростой. Спасибо вам и успехов!
- id: 141769
  author: SlowProg
  author_email: paperplanesu@rambler.ru
  author_url: http://paperplane.su
  date: '2013-03-22 16:56:46 +0400'
  date_gmt: '2013-03-22 12:56:46 +0400'
  content: Добрый! Очень рад вашему настрою. При возникновении вопросов задавайте
    их мне. Статья довольно объёмная и я мог что-то упустить или запутать повествования,
    и думаю, она еще не раз будет подкорректирована.
- id: 219214
  author: Денис
  author_email: deniskolesnikov@list.ru
  author_url: ''
  date: '2014-01-14 12:53:33 +0400'
  date_gmt: '2014-01-14 08:53:33 +0400'
  content: "Большое спасибо автору за такие подробные статьи. Уже второй день изучаю
    ваш сайт, только здесь нашел внятное описание многих непонятных вопросов. Например,
    раньше я понять не мог что такое хуки в вордпресе, что такое фреймворк, а здесь
    случайно нашел ответы. \r\nС БД MySQL тоже пробовал немного работать, но здесь
    мне очень понравилось описание на конкретном и не самом простом, для понимания
    новичком, примере. \r\nЧтобы понять до конца надо будет это ещё перечитать и всё
    попробовать самому.\r\nЕще раз СПАСИБО!"
- id: 219222
  author: SlowProg
  author_email: paperplanesu@rambler.ru
  author_url: http://paperplane.su
  date: '2014-01-14 13:38:38 +0400'
  date_gmt: '2014-01-14 09:38:38 +0400'
  content: не за что! Учитесь, постигайте. На этом не останавливайтесь. пытайтесь
    что-то своё замутить, это будет вынуждать читать документацию. так мы и учимся
    =))))
- id: 219234
  author: Денис
  author_email: deniskolesnikov@list.ru
  author_url: http://do-profit.com
  date: '2014-01-14 14:57:21 +0400'
  date_gmt: '2014-01-14 10:57:21 +0400'
  content: "Спасибо. Я уже пытаюсь замутить )). \r\nПока особо успехов почти нет -
    сайт на вордпресе сделал со стандартным шаблоном, иногда пишу статейки, но дизайн
    мне очень не нравится, надо что-то делать. \r\nЕщё пробовал на Джумле сайт сделать,
    но она мне очень не понравилась, переделал на Друпале - он хоть не глючит. \r\nНаписал
    пару скриптов на php это наверное моё самое большое личное достижение в сайтостроительстве
    ;)   Один скрипт из набора однотипных html страничек выдёргивает данные и строит
    графики, плюс некоторые значения пишутся в базу данных, а потом по ним тоже строится
    рейтинг другим скриптом. \r\nДля специалиста это наверное дело 1-2 дней, а я провозился
    наверное пару недель. \r\nНО вот проблема, графики и рейтинг мне надо мне периодически
    обновлять для этого я вручную сохраняю html странички из браузера (их порядка
    30 шт), потом закачиваю на хостинг, там запускаю скрипт который обновляет БД для
    рейтинга. \r\nЯ хотел автоматизировать этот процесс, но возникли проблемы. Если
    открывать странички с удалённого сервера, то они не грузятся (похоже там защита
    от роботов через куки).  Если html закачивать программой закачки, то грузятся
    английские версии (изначально в браузере английский и можно выбирать другой язык).
    \r\nОй, я тут загрузил вас. Извините :)"
- id: 219244
  author: SlowProg
  author_email: paperplanesu@rambler.ru
  author_url: http://paperplane.su
  date: '2014-01-14 15:58:18 +0400'
  date_gmt: '2014-01-14 11:58:18 +0400'
  content: Ну в общем и целом, сложно сказать как поступить в этой ситуации поскольку
    перед глазами ничего нет. Но если страницы с сервака не тянуться значит нужно
    поискуснее попробовать маскироваться. Заголовки как будето от нормального пользователя
    посылать. Например, useragent существующий, с работающими куками и в реферер установить
    их главную страницу. Это всё умеет делать Curl. В принципе, на php всё можно реализовать,
    но нужно статейки полистать. Нужно пробовать. Парсинг не самое простое дело, особенно,
    если с той стороны умный парень =)
- id: 251514
  author: 'Quest For Family Wholeness: Providing Spiritual Covering for Your Family
    downloads'
  author_email: ''
  author_url: http://www.onlinebooksclub.com/Quest-For-Family-Wholeness-Providing-Spiritual-Covering-for-Your-Family/p1815322414/
  date: '2015-06-13 13:12:06 +0300'
  date_gmt: '2015-06-13 09:12:06 +0300'
  content: |-
    <strong>Quest For Family Wholeness: Providing Spiritual Covering for Your Family<&#47;strong>

    Quest for Family Wholeness is an account of the journey of Mary Wenger to bring her family from brokenness to wholeness. In the process, the relationship
---
<p><a href="http:&#47;&#47;image.paperplane.su&#47;2013&#47;03&#47;mysql-lesson.png"><img src="http:&#47;&#47;image.paperplane.su&#47;2013&#47;03&#47;mysql-lesson-300x300.png" alt="Основы MySQL для начинающих WordPress блогеров" title="Основы MySQL для начинающих WordPress блогеров" width="300" height="300" class="alignleft size-medium wp-image-2836" &#47;><&#47;a>Сегодня я продолжу свой курс PHP для начинающих блогеров с уклоном на WordPress. В предыдущем уроке я дал <a title="Урок 1: Основы PHP для начинающих WordPress блогеров" href="http:&#47;&#47;paperplane.su&#47;urok-1-osnovy-php-dlya-nachinayushhix-blogerov-wordpress&#47;" target="_blank">основные понятия PHP<&#47;a>, которые должны помочь читать простой код даже не умеющим программировать блогерам. Но как мы знаем, WordPress для своей работы так же использует и базу данных, как правило MySQL. Именно поэтому сегодняшний урок я решил посвятить разбору основ работы с базой данных MySQL. Забегая вперед я скажу, что при определенном желании WordPress можно адаптировать для работы с другими базами, для этого есть даже различные плагины, но по-дефолту используется всегда Мускул (жаргонное произношение MySQL), потому его мы и будем рассматривать в этом уроке.</p>
<h2>Теория MySQL<&#47;h2><br />
Если вы спросите: "Что такое MySQL?", то многие ответят, что это СУБД. А что же такое СУБД? Википедия по этому поводу нам повествует следующее определение:</p>
<blockquote><p><strong>Система управления базами данных<&#47;strong> (СУБД) - это совокупность программных и лингвистических средств общего или специального назначения, обеспечивающих управление созданием и использованием баз данных.<&#47;blockquote><br />
И я с ней полностью согласен. Могу только добавить, что СУБД бывают разных типов, каждый из которых обуславливает свои принципы хранения и манипуляцию с данными, но я обо всех рассказывать не буду, только об одном, которым и является MySQL.</p>
<p>Мускул является так называемой <em>реляционной<&#47;em> СУБД. Понятие реляционный произошло от английского слова relation &mdash; отношение. В этом собственно и есть соль всего понятия. Есть сущности (таблицы), между которыми существуют определенные отношения (связи). Реляционная модель ориентирована на организацию данных в виде двумерных массивов, другими словами в виде обычных таблиц. Каждая реляционная таблица обладает следующими свойствами:</p>
<ul>
<li><strong>Каждая таблица является двумерной<&#47;strong> т.е. есть строки (их также называют картежи или записи) и столбцы (поля или атрибуты).<&#47;li>
<li><strong>Все элементы в столбце имеют одинаковый тип и длину<&#47;strong>. В принципе, большинство типов такие же как в PHP (название может быть другое, но суть одна): строковые (VARCHAR), целочисленные (INT), дробные (NUMERIC), дата и время (DATETIME) и др. Более подробно о разных типах можете почитать <a rel="nofollow" href="http:&#47;&#47;www.spravkaweb.ru&#47;mysql&#47;sql&#47;vartype&#47;" title="Типы данных MySQL" target="_blank">тут<&#47;a>.<&#47;li>
<li><strong>Каждый столбец имеет уникальное имя<&#47;strong>.<&#47;li>
<li><strong>Все строки в таблице уникальны<&#47;strong> т.е. в двух различных кортежах никогда не повторяются все атрибуты разом (это не обязательное, но желательно требование, подробней о <a rel="nofollow" href="http:&#47;&#47;ru.wikipedia.org&#47;wiki&#47;%D0%9D%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%84%D0%BE%D1%80%D0%BC%D0%B0" title="Нормальная форма" target="_blank">нормализации данных<&#47;a>).<&#47;li>
<li><strong>Порядок следования строк и столбцов &ndash; произвольный<&#47;strong>.<&#47;li><br />
<&#47;ul><br />
Отношения, которые существуют между таблицами накладывают определенные ограничение на использование данных. Но в эту сторону я углубляться не буду т.к. в базе данных WordPress между таблицам не используются связи, все связи реализуются на уровне запросов, которые мы рассмотрим ниже.</p>
<h2>Запросы MySQL<&#47;h2><br />
Запросы к базе данных - это обращения для изменения или получения данных из таблиц. А язык, который использует Мускул для организации запросов, называется <em><a title="Язык запросов SQL" href="http:&#47;&#47;ru.wikipedia.org&#47;wiki&#47;SQL" target="_blank">SQL<&#47;a><&#47;em> (с англ. Structured Query Language &mdash; Язык Структурированных Запросов). У этого языка существует приличное количество операторов для работы с данными, но нам понадобятся только те, которые производят манипуляции с данными (остальные изучаем самостоятельно):</p>
<ul>
<li><strong>SELECT<&#47;strong> &mdash; считывает данные из таблицы, удовлетворяющие заданным условиям.<&#47;li>
<li><strong>INSERT<&#47;strong> &mdash; добавляет новые данные в таблицу.<&#47;li>
<li><strong>UPDATE<&#47;strong> &mdash; изменяет существующие данные в таблице, удовлетворяющие заданным условиям.<&#47;li>
<li><strong>DELETE<&#47;strong> &mdash; удаляет существующие данные из таблицы, удовлетворяющие заданным условиям.<&#47;li><br />
<&#47;ul><br />
Именно с этими операторами в WordPress больше всего и работают. Как правило, создавать сами таблицы нужды нет, если только вы не нацелены на написание плагина, который будет юзать базу.</p>
<p>В запросах используются свои служебные зарезервированные слова, которые разделяют запрос на некоторое количество логических частей. Опять же, их очень много, но рассмотрю я только самые популярные:</p>
<ul>
<li><strong>FROM<&#47;strong> &mdash; служебное слово, после которого указывается таблица (таблицы), к которой будет применен запрос, или вместо таблицы может быть даже целый подзапрос, результаты которого и будут использоваться в выборке (пример этого будет ниже).<&#47;li>
<li><strong>AS<&#47;strong> &mdash; данный оператор назначает алиас (псевдоним) для выражения стоящего слева от него (сам псевдоним справа от оператора). Это необходимо для краткого наименования чего бы то ни было. Например, длинные названия таблиц (столбцов, результатов подзаросов) можно заменить в запросе на более короткие, даже однобуквенные.<&#47;li>
<li><strong>WHERE<&#47;strong> &mdash; служебное слово, после которого идут условия выборки данных.<&#47;li>
<li><strong>AND<&#47;strong> &mdash; логический оператор "И" для написания условий (тоже самое что и в PHP).<&#47;li>
<li><strong>OR<&#47;strong> &mdash; логический оператор "ИЛИ" для написания условий (тоже самое что и в PHP).<&#47;li>
<li><strong>NOT<&#47;strong> &mdash; логическое отрицание для написания условий (как в PHP восклицательный знак), просто меняет значение булеановской переменной на противоположное (делая смысл всего выражения стоящего после него противоположным).<&#47;li>
<li><strong>ORDER BY<&#47;strong> &mdash; служит для определения столбцов, по которым будет происходить сортировка данных (используется для SELECT) по убыванию (DESC) или возрастанию (ASC).<&#47;li>
<li><strong>GROUP BY<&#47;strong> &mdash; служит для объединения результирующих строк по заданным атрибутам, т.е. делая тем самым выбранные атрибуты уникальными в результатах (ниже из примера понятнее будет, надеюсь).<&#47;li>
<li><strong>LIMIT<&#47;strong> &mdash; ключевое слово после, которого указывается сколько возвратить результатов запроса. Например, при <em>LIMIT 10<&#47;em> даже, если под условие выборки подходит 30 кортежей будет возвращено все равно 10 первых кортежей. А если написать <em>LIMIT 5 10<&#47;em>, то будет возвращено 10 кортежей начиная с 5го. (используется для SELECT)<&#47;li><br />
<&#47;ul><br />
Ну вот вроде бы для начало неплохо, дальше смотрите необходимые команды и операторы самостоятельно, а теперь давайте ниже рассмотрим синтаксис и примеры всех этих операторов.</p>
<h2>Синтаксис операторов манипуляции с данными<&#47;h2><br />
Для рассмотрения примеров использования операторов мы возьмем стандартную таблицу из WordPress, в которой хранятся все метки <em>wp_terms<&#47;em> с уже заполненными несколькими кортежами:</p>
<table class="aligncenter" border="1">
<tbody>
<tr>
<th>term_id<&#47;th></p>
<th>name<&#47;th></p>
<th>slug<&#47;th></p>
<th>term_group<&#47;th><br />
<&#47;tr></p>
<tr>
<td>1<&#47;td></p>
<td>PHP<&#47;td></p>
<td>php<&#47;td></p>
<td>0<&#47;td><br />
<&#47;tr></p>
<tr>
<td>2<&#47;td></p>
<td>MySQL<&#47;td></p>
<td>mysql<&#47;td></p>
<td>0<&#47;td><br />
<&#47;tr></p>
<tr>
<td>3<&#47;td></p>
<td>Создание сайта<&#47;td></p>
<td>sozdanie-sajta<&#47;td></p>
<td>1<&#47;td><br />
<&#47;tr><br />
<&#47;tbody><br />
<&#47;table><br />
В принципе, таблица сама по себе понятная, но тем не менее я поясню столбцы:</p>
<ul>
<li><em>term_id<&#47;em> - идентификатор кортежа (его уникальный номер), он необходим для того, чтобы кортеж никогда не повторился. При добавлении нового кортежа он добавляется автоматически автоинкриментом, который к предыдущем автоматически прибавляет единицу, т.е. в конечном итоге получается последовательность чисел от 1 и до сколь угодно (ограничивается конкретной версией MySQL).<&#47;li>
<li><em>name<&#47;em> - имя метки, которое добавил пользователь.<&#47;li>
<li><em>slug<&#47;em> - вариант написания метки для использования в URL.<&#47;li>
<li><em>term_group<&#47;em> - группа метки.<&#47;li><br />
<&#47;ul><br />
В начале мы рассмотрим <strong>SELECT<&#47;strong>. Обычно выборка осуществляется из одной или нескольких таблиц. В последнем случае частенько используется операция слияния (JOIN). Но это уже выходит за рамки этого курса, я считаю это слишком сложено для начинающих. Так же хочу заметить, что в описании синтаксиса будут использоваться условные обозначения: [] - необязательная часть, < > - изменяемая часть. Общий синтаксис оператора следующий:<br />
[cce lang="sql"]SELECT <список_атрибутов> FROM <список_таблиц> [WHERE <список_условий>][&#47;cce]<br />
Теперь давайте составим запрос с выборкой из таблицы меток. Пусть нам нужно возвратить все атрибуты (столбцы) тех кортежей (строк), у которых атрибут <em>term_group<&#47;em> равен единице или нулю. И, например, нам нужно по одному примеру метки из каждой группы - проведем объединение по номеру группы (при это после объединения по одинаковому номеру остается первая попавшаяся запись). Для того чтобы отобрать все атрибуты, не обязательно всех их перечислять через запятую, достаточно поставить "*" (звездочку) и MySQL вернет все атрибуты. Вот сам запрос:<br />
[cce lang="sql"]SELECT * FROM wp_terms WHERE term_group = 1 OR term_group = 0 GROUP BY term_group;[&#47;cce]<br />
Сам по себе запрос очень глупый, но для иллюстрации подходит. Результат данного запроса:</p>
<table class="aligncenter" border="1">
<tbody>
<tr>
<th>term_id<&#47;th></p>
<th>name<&#47;th></p>
<th>slug<&#47;th></p>
<th>term_group<&#47;th><br />
<&#47;tr></p>
<tr>
<td>1<&#47;td></p>
<td>PHP<&#47;td></p>
<td>php<&#47;td></p>
<td>0<&#47;td><br />
<&#47;tr></p>
<tr>
<td>3<&#47;td></p>
<td>Создание сайта<&#47;td></p>
<td>sozdanie-sajta<&#47;td></p>
<td>1<&#47;td><br />
<&#47;tr><br />
<&#47;tbody><br />
<&#47;table><br />
Теперь рассмотрим операцию добавления <strong>INSERT<&#47;strong>. Она просто добавляет новый кортеж в указанную таблицу и ничего не возвращает в ответ. В общем виде синтаксис выглядит следующим образом:<br />
[cce lang="sql"]INSERT INTO <название_таблицы> ([<имя_атрибута>, ... ]) VALUES (<значение>,...)[&#47;cce]<br />
Попробуем применить её на практике. Допустим нам нужно добавить в таблицу новую метку под названием <em>JavaScript<&#47;em>, соответственно slug будет <em>javascript<&#47;em> и term_group пусть будет 0. Для добавления этого кортежа необходимо выполнить следующий запрос:<br />
[cce lang="sql"]INSERT INTO wp_terms (name, slug, term_group) VALUES ('JavaScript', 'javascript', 0)[&#47;cce]<br />
Обратите внимание, что атрибут term_id мы не прописали т.к. он заполняется автоматически автоинкриментом, т.е. увеличивается на единицу в сравнении с последней добавленной записью. После выполнения запроса таблица будет выглядеть следующим образом:</p>
<table class="aligncenter" border="1">
<tbody>
<tr>
<th>term_id<&#47;th></p>
<th>name<&#47;th></p>
<th>slug<&#47;th></p>
<th>term_group<&#47;th><br />
<&#47;tr></p>
<tr>
<td>1<&#47;td></p>
<td>PHP<&#47;td></p>
<td>php<&#47;td></p>
<td>0<&#47;td><br />
<&#47;tr></p>
<tr>
<td>2<&#47;td></p>
<td>MySQL<&#47;td></p>
<td>mysql<&#47;td></p>
<td>0<&#47;td><br />
<&#47;tr></p>
<tr>
<td>3<&#47;td></p>
<td>Создание сайта<&#47;td></p>
<td>sozdanie-sajta<&#47;td></p>
<td>1<&#47;td><br />
<&#47;tr></p>
<tr>
<td>4<&#47;td></p>
<td>JavaScript<&#47;td></p>
<td>javascript<&#47;td></p>
<td>0<&#47;td><br />
<&#47;tr><br />
<&#47;tbody><br />
<&#47;table><br />
Теперь рассмотрим операцию <strong>UPDATE<&#47;strong>. Эта операция позволяет обновить значения в заданных столбцах таблицы. Синтаксис её выглядит следующим образом:<br />
[cce lang="sql"]UPDATE <название_таблицы> SET <имя_атрибута> = <новое_значение> [, ...] [WHERE <список_условий>][&#47;cce]<br />
Попробуем обновить  помощью этой команды сразу несколько кортежей. Допустим нам нужно присвоить атрибуту <em>term_group<&#47;em> единицу у всех кортежей, где этот же атрибут равен нулю. Ничего сложного:<br />
[cce lang="sql"]UPDATE wp_terms SET term_group = 1 WHERE term_group = 0[&#47;cce]<br />
После исполнения этого запроса таблица будет выглядеть так:</p>
<table class="aligncenter" border="1">
<tbody>
<tr>
<th>term_id<&#47;th></p>
<th>name<&#47;th></p>
<th>slug<&#47;th></p>
<th>term_group<&#47;th><br />
<&#47;tr></p>
<tr>
<td>1<&#47;td></p>
<td>PHP<&#47;td></p>
<td>php<&#47;td></p>
<td>1<&#47;td><br />
<&#47;tr></p>
<tr>
<td>2<&#47;td></p>
<td>MySQL<&#47;td></p>
<td>mysql<&#47;td></p>
<td>1<&#47;td><br />
<&#47;tr></p>
<tr>
<td>3<&#47;td></p>
<td>Создание сайта<&#47;td></p>
<td>sozdanie-sajta<&#47;td></p>
<td>1<&#47;td><br />
<&#47;tr></p>
<tr>
<td>4<&#47;td></p>
<td>JavaScript<&#47;td></p>
<td>javascript<&#47;td></p>
<td>1<&#47;td><br />
<&#47;tr><br />
<&#47;tbody><br />
<&#47;table><br />
И последняя операция <strong>DELETE<&#47;strong>. Она позволяет удалять записи из таблицы. Критерий отбора записей для удаления определяется с помощью <em>WHERE<&#47;em>. В случае, если критерий отбора не определён, выполняется удаление всех записей. Синтаксис операции выглядит следующим образом:<br />
[cce lang="sql"]DELETE FROM <название_таблицы> [WHERE <список_условий>][&#47;cce]<br />
Давайте попробуем удалить сразу два кортежа, у которых <em>slug<&#47;em> равен <em>php<&#47;em> или <em>mysql<&#47;em>. Элементарно:<br />
[cce lang="sql"]DELETE FROM wp_terms WHERE slug = 'php' or slug = 'mysql'[&#47;cce]<br />
После исполнения этого запроса таблица будет выглядеть так:</p>
<table class="aligncenter" border="1">
<tbody>
<tr>
<th>term_id<&#47;th></p>
<th>name<&#47;th></p>
<th>slug<&#47;th></p>
<th>term_group<&#47;th><br />
<&#47;tr></p>
<tr>
<td>3<&#47;td></p>
<td>Создание сайта<&#47;td></p>
<td>sozdanie-sajta<&#47;td></p>
<td>1<&#47;td><br />
<&#47;tr></p>
<tr>
<td>4<&#47;td></p>
<td>JavaScript<&#47;td></p>
<td>javascript<&#47;td></p>
<td>1<&#47;td><br />
<&#47;tr><br />
<&#47;tbody><br />
<&#47;table><br />
Надеюсь, примерно как составлять простые запросы для MySQL вам стало ясно. На практике запросы конечно же более сложные, с большем числом условий и другой ерундистики, но это дело наживное. Если вы будете дальше углублять свои знания и пытаться самостоятельно составлять запросы, то со временем и опытом у вас всё получится. У всех так было.</p>
<h2>Применение MySQL в WordPress<&#47;h2><br />
Теперь давайте рассмотрим, как производить запросы в базу данных из WordPress при написании своих кодов, которые должны взаимодействовать с базой. Конкретно тут рассмотрим пример взаимодействия с базой данных из <em>functions.php<&#47;em> вашей темы, т.к. это довольно популярная задача, которая частенько встречается. Например, при разработке различных "<a href="http:&#47;&#47;paperplane.su&#47;blog&#47;wordpress&#47;bez-plagina-wordpress&#47;" title="WordPress без плагина" target="_blank">безплагинов<&#47;a>". И в данном разделе мы будем рассматривать работу с базой WordPress на основе моего <a href="http:&#47;&#47;paperplane.su&#47;top-kommentatorov-bez-plagina-v-wordpress&#47;" title="Топ комментаторов без плагина в WordPress" target="_blank">ТОПа комментаторов<&#47;a> (откройте эту статью в соседней вкладке браузера, чтобы удобнее было смотреть). Настоятельно рекомендую прочитать эту статью, если вы её ранее не читали, чтобы понимать для чего эта функция и переменные внутри неё. При беглом просмотре кода функции можно заметить довольно большой запрос, вот его то мы и будем рассматривать.</p>
<p>В общих чертах, процесс запроса в базу данных из приложения выглядит так: приложение инициирует соединение с базой, производит необходимые действия (различные запросы) и разрывает соединение. В случае с WordPress мы можем абстрагироваться от операций соединения и разрыва коннекта с базой и сосредоточится только на конкретных запросах, всё остальное за нас сделает сам WordPress. Т.к. в нем есть глобальная переменная, которая содержит, готовый к работе, активный коннект с базой. Всё, что нужно, это получить эту переменную и именно это мы и делаем во второй строчке кода - получаем глобальную переменную <em>$wpdb<&#47;em>. Это обязательное действие! Далее именно через неё происходит вся работа с базой данных WordPress.</p>
<p>По сути, у переменной <em>$wpdb<&#47;em> есть много функций для работы с базой данных и полученными данными конкретно (о них подробнее <a rel="nofollow" href="http:&#47;&#47;codex.wordpress.org&#47;Class_Reference&#47;wpdb" target="_blank">тут<&#47;a>), но в большинстве случаев достаточно всего одной функции:</p>
<blockquote><p><strong>$wpdb->get_results('query');<&#47;strong> - функция возвращает результат запроса <em>'query'<&#47;em> в массиве, каждый элемент которого представляет собой отельный кортеж (как объект данных) с атрибутами, значение которых доступно через стрелочку (<em>-><&#47;em>).<&#47;blockquote><br />
Также переменная <em>$wpdb<&#47;em> содержит название таблиц. Это необходимо для обеспечения переносимости кода, т.е. он будет работать в любом проекте, как бы там таблицы не назывались, а точнее, какой бы префикс не использовался. Префикс - это приставка к стандартному названию таблицы WordPress через нижний слеш (подчеркивание _), она необходима для обеспечения безопасности, чтобы никто не знал как на самом деле называются у вас таблицы. По умолчанию префикс <em>wp<&#47;em> (например <em>wp_terms<&#47;em>), но при установке WordPress в самом начале его можно сделать любым. И вот для того чтобы код был переносимый не зависимо от префикса, можно получать названия таблицы через <em>$wpdb<&#47;em>, например, название той же таблицы <em>wp_terms<&#47;em> можно получить <em>$wpdb->terms<&#47;em> и в другом проекте, где она будет называться <em>lol_terms<&#47;em> ваш код будет всё так же хорошо работать. Более подробно о том какие переменные отвечают за какие таблицы смотрите <a rel="nofollow" href="http:&#47;&#47;codex.wordpress.org&#47;Class_Reference&#47;wpdb#Tables" target="_blank">тут<&#47;a>.</p>
<p>Теперь я попытаюсь рассмотреть все нюансы данного запроса по отдельности, которые могут вызвать вопросы. После этого вы должны мочь прочитать этот запрос с полным осознанием того, что там творится, но чтобы вам не в чем не сомневаться, я тоже прочитаю этот запрос, но после пояснения нюансов.</p>
<p>Для начала, запрос будет производится только в одну таблицу <em>wp_comments<&#47;em>, структуру которой можно поглядеть <a rel="nofollow" href="http:&#47;&#47;codex.wordpress.org&#47;Database_Description#Table:_wp_comments" target="_blank">тут<&#47;a> (там же можно изучить и структуры других стандартных таблиц). Эта таблица предназначена для хранения комментариев, т.е. один кортеж - это один комментарий со всеми сопутствующими данными (мыло и имя автора, дата оставления, текст комментария и др.).</p>
<p>Рассмотрим некоторые SQL-функции и конструкции, которые есть в этом запросе, и которых мы ранее не касались:</p>
<ul>
<li><strong>COUNT()<&#47;strong> - данная функция подсчитывает число строк в данных возвращаемых запросом. Причем, если в качестве аргумента этой функции выступает * (звездочка), то подсчитываются все строки таблицы. А если имя столбца, то только те строки, которые имеют значение в указанном столбце, т.е. NULL значения не будут учитываться. Эта функция относится к групповым, о которых можете почитать подробней <a rel="nofollow" href="http:&#47;&#47;www.php.su&#47;mysql&#47;manual&#47;?page=Group_by_functions" target="_blank">тут<&#47;a>. В нашем случае <em>COUNT<&#47;em> используется для подсчёта количества комментариев для каждого комментатора по его почте (подсчитываем именно количество одинаковых почт).<&#47;li>
<li><strong>IN<&#47;strong> - данный оператор позволяет задавать только несколько определенных допустимых значений для какого-либо атрибута в условии. Т.е. будут допускаться только те значения, которые есть в операторе. Например, [cci lang='sql']... WHERE id IN (1,3,65)[&#47;cci] тут будут отбираться только те кортежи, где id равно либо 1, либо 3, либо 65. Но в нашем случае, перед всей конструкцией стоит <em>NOT<&#47;em>, который заставляет работать оператор <em>IN<&#47;em> с точностью да наоборот: мы ищем все мыла кроме указанных в скобках. Именно так мы исключаем из результата мыла-исключения (мыла админа и забаненых пользователей).<&#47;li>
<li><strong>NOW()<&#47;strong> - данная функция возвращает текущую дату и время, как величину в формате YYYY-MM-DD HH:MM:SS.<&#47;li>
<li><strong>MONTH()<&#47;strong> - данная функция возвращает порядковый номер месяца в году для указанной в ней даты в диапазоне от 1 до 12.<&#47;li>
<li><strong>YEAR()<&#47;strong> - данная функция возвращает год для указанной в ней даты в диапазоне от 1000 до 9999.<&#47;li><br />
<&#47;ul><br />
Теперь некоторые нюансы на словах попробую объяснить:</p>
<ul>
<li>Вы могли заметить, что в секции FROM не указана конкретная таблица, а написан подзапрос. В данном случае происходит предварительная сортировка данных по убыванию идентификатора (фактически по убыванию порядка добавления комментария) перед последующей основной выборкой. А результаты подзапроса становятся доступными по указанному алиасу <em>pc<&#47;em>, но это нужно только для факта, сам алиас мы в последующем использовать не будем, хотя могли бы ко всем полям в запросе обращаться через него (например, <em>pc.comment_author_email<&#47;em>).<&#47;li>
<li>В 20 строке кода мы указываем какие мыла не должны отображаться в ТОПе, используя ранее описанный оператор <em>IN<&#47;em>, но значения для этого оператора мы получаем из PHP-переменной <em>$exceptionEmail<&#47;em>, где мыла просто перечислены через запятую. Можно было бы просто конкатенировать (термин из прошлого урока, присоединить) значение переменной со строкой-запросом, но дело в том, что тип этого поля (comment_author_email) строковый (varchar), а строки все указываются в кавычках. Потому каждое мыло нужно заключить в кавычки, для этого я использую PHP-функцию <a rel="nofollow" href="http:&#47;&#47;www.php.net&#47;manual&#47;ru&#47;function.preg-replace.php" target="_blank">preg_replace()<&#47;a>, о которой вы можете почитать сами.<&#47;li>
<li>В последней строке условия (21) вы можете заметить что-то связанное с месяцами. Тут замешан PHP, как будет выглядеть конечное условие в запросе зависит от значения PHP-переменной <em>$month<&#47;em>. Тут использовано сокращенное написания условия <em>if<&#47;em>. Грубо говоря, вся 21 строка читается примерно так: если переменная <em>$month<&#47;em> равна <em>true<&#47;em>, то конкатенируем к строке с запросом следующую строку <em>AND month(comment_date) = month(now()) AND year(comment_date) = year(now())<&#47;em>, в противном случае, если <em>$month<&#47;em> равна <em>false<&#47;em>, то конкатенируем пустую строку, т.е. ничего не присоединяем, всё так и остаётся. Думаю понятно, что длинная строка с месяцем и годом устанавливает условие, которое ограничивает выборку в пределах текущего месяца текущего года.<&#47;li><br />
<&#47;ul><br />
Более-менее все нюансы данного запроса я рассмотрел, остальное уже так или иначе мы затрагивали. Теперь вы, надеюсь, можете прочитать его примерно понимая какие данные он отбирает из базы и как. Но чтобы не было недосказанности, я прочитаю его вместе с вами. Для начала, давайте сформируем конечный запрос, который получится после исполнения всех действий PHP. Формировать запрос будем с переменными, которые идут по-умолчанию из функции в статье:<br />
[cce lang="sql"]<br />
SELECT<br />
	COUNT(comment_author_email) AS comments_count, comment_author_email, comment_author, comment_author_url<br />
FROM<br />
	(select * from wp_comments order by comment_ID desc) as pc<br />
WHERE<br />
	comment_author_email != "" AND<br />
	comment_type = "" AND<br />
	comment_approved = 1 AND<br />
	comment_author_email NOT IN ("mail1@dom.ru", "mail2@mod.ru")<br />
GROUP BY<br />
	comment_author_email<br />
ORDER BY<br />
	comments_count DESC<br />
LIMIT 12<br />
[&#47;cce]<br />
Производим запрос на выборку данных (SELECT). Выборку данных производим из предварительно отсортированной таблицы <em>wp_comments<&#47;em> (FROM). Из этой таблицы нам необходимо подсчитать количество мыл (означающее количество комментариев владельца этого мыла), которое мы обзовём (алиса) <em>comments_count<&#47;em>, само мыло, имя автора комментариев и адрес его сайта. Далее по условию (WHERE) нам необходимы выше перечисленные данные только тех кортежей, где мыло не пустое, тип комментария пустой (может быть pingback или trackback), комментарий должен быть одобренный (1 - одобрен, 0 - не одобрен), мыло, к которому приписан комментарий, не должен содержать mail1@dom.ru и mail2@mod.ru. Далее все отобранные данные группируются (GROUP BY) по мылу, т.е. в поле <em>comment_author_email<&#47;em> в результате все мыла будут уникальными и каждому мылу будет соответствовать своё количество комментариев (<em>comments_count<&#47;em>) и др. Для того чтобы знать кто больше накомментировал мы отсортируем (ORDER BY) все результаты по убыванию значения <em>comments_count<&#47;em> т.е. в самом верху будут те кто больше комментариев оставил, а внизу те кто меньше. И наконец, в результате оставим только первые 12 кортежей (LIMIT) т.к. остальные нам и не нужны, потому что наш ТОП будет состоять только из 12 комментаторов.</p>
<p>Надеюсь, я доступно прочитал запрос и у вас не осталось сомнений в том, что конкретно он делает. Если это не так, то отдохните немного и прочитайте еще раз позже, а то информации в статье достаточно много для осознания и запоминания за один раз. Главное, используйте преобретённые навыки и развивайте их: прочитайте свой код в <em>functions.php<&#47;em>, попробуйте понять, что он конкретно делает, в случае непонимания чего-бы то ни было сразу гуглите это, описание всех функций и любого действия есть в документации и многочисленных статьях. В дальнейшем при работе с безплагинами старайтесь понять, что именно делает функция и какие именно данные отбирает запрос из базы (если он там есть). Как только ваш навык понимания кода станет достаточным, вы сможете сами его писать, или хотя бы осознанно редактировать чужой.</p>
<p>Стремитесь к совершенству, читайте, познавайте, учитесь, главное, не стесняйтесь своего незнания и спрашивайте у знающих людей, задавайте вопросы, но только после того, как самостоятельные поиски ответа зашли в тупик, т.е. <a href="http:&#47;&#47;paperplane.su&#47;google-search&#47;" title="Поиск в Гугле" target="_blank">гугление<&#47;a> не помогает. На этому у меня всё, надеюсь, я посеял в ваших головах зёрна знаний. Постараюсь продолжить этот цикл статей, особенно если эта статья придётся по душе читателям. Пишите ваши замечания, вопросы, пожелания и мнения в комментарии. Всем удачи!</p>
