---
layout: post
status: publish
published: true
title: Выпадающий список с автозаполнением на jQuery UI
author:
  display_name: SlowProg
  login: seoadmin
  email: paperplanesu@rambler.ru
  url: http://paperplane.su
author_login: seoadmin
author_email: paperplanesu@rambler.ru
author_url: http://paperplane.su
wordpress_id: 1657
wordpress_url: http://paperplane.su/?p=1657
date: '2011-12-05 15:00:48 +0400'
date_gmt: '2011-12-05 15:00:48 +0400'
categories:
- jQuery
tags:
- jquery
- автозаполнение
comments:
- id: 34056
  author: Константин
  author_email: 1@12.er
  author_url: ''
  date: '2012-01-14 11:17:07 +0400'
  date_gmt: '2012-01-14 07:17:07 +0400'
  content: Спасибо за статью, сам давно хотел такое сделать на своем сайте!!
- id: 34060
  author: SlowProg
  author_email: paperplanesu@rambler.ru
  author_url: http://paperplane.su
  date: '2012-01-14 12:14:57 +0400'
  date_gmt: '2012-01-14 08:14:57 +0400'
  content: Не за что =) Всегда рад =)
- id: 43138
  author: Dimazan
  author_email: dimazan@mail.ru
  author_url: ''
  date: '2012-03-11 12:28:20 +0400'
  date_gmt: '2012-03-11 08:28:20 +0400'
  content: "Спасибо за подробное описание.\r\n\r\nНо столкнулся с проблемой - не работает
    при нескольких автозаполняемых селектах на странице.\r\nТо есть есть 2 селекта
    и для них прописано:\r\n$(\"select1\").combobox();\r\n$(\"select2\").combobox();\r\nНо
    список элементов для автозаполнения везде от первого селекта.\r\nПодскажите, плиз,
    как это побороть?"
- id: 43140
  author: Dimazan
  author_email: dimazan@mail.ru
  author_url: ''
  date: '2012-03-11 13:11:43 +0400'
  date_gmt: '2012-03-11 09:11:43 +0400'
  content: "Ребята сори!\r\nДосадная очепятка закралась.\r\nВсе прекрасно работает
    и с несколькими селектами!"
- id: 43141
  author: SlowProg
  author_email: paperplanesu@rambler.ru
  author_url: http://paperplane.su
  date: '2012-03-11 13:45:34 +0400'
  date_gmt: '2012-03-11 09:45:34 +0400'
  content: Все хорошо, что хорошо кончается =D Особенно когда сам додумал =)
- id: 127771
  author: Андрей
  author_email: securitycop@gmail.com
  author_url: ''
  date: '2012-12-04 12:46:11 +0400'
  date_gmt: '2012-12-04 08:46:11 +0400'
  content: Здравствуйте, еще бы демку посмотреть. Кстати, если такой поиск так хорош,
    почему Вы на своем сайте его не используете?
- id: 127823
  author: SlowProg
  author_email: paperplanesu@rambler.ru
  author_url: http://paperplane.su
  date: '2012-12-04 19:09:33 +0400'
  date_gmt: '2012-12-04 15:09:33 +0400'
  content: "Демка, я думал, пойдет на офсайте, но ладно я и свою выложу. Ссылка в
    самом низу статьи. \r\n\r\nА у себя не использую, потому что оно мне не нужно.
    Где? В поиске? Его редко кто юзает, и даже если, то что туда в селект пихать?
    Все возможные запросы? Это не то место, где нужно юзать этот виджет."
- id: 141781
  author: kris
  author_email: kris@yandex.ru
  author_url: ''
  date: '2013-03-22 19:04:28 +0400'
  date_gmt: '2013-03-22 15:04:28 +0400'
  content: "а можно такое же, только без кнопки\r\nт.е. по текстовому полю клик и
    выпал список\r\nспасибо"
- id: 141784
  author: SlowProg
  author_email: paperplanesu@rambler.ru
  author_url: http://paperplane.su
  date: '2013-03-22 19:16:18 +0400'
  date_gmt: '2013-03-22 15:16:18 +0400'
  content: "Конечно можно. С ходу не скажу, не охота вспоминать сейчас, что там понаписал
    давно =) Да и времени сейчас нет. Но всегда  можно кнопку скрыть стилями, например
    так:\r\n<code>button.ui-button {\r\ndisplay: none;\r\n}<&#47;code>\r\nНо так скроются
    все кнопки в jQuery UI xDDDDD Что наверно не желательно. Просто кнопке присвойте
    свой уникальный стиль. А лучше разберитесь в коде и просто удалите добавление
    кнопки. В cnnmt тем более написано где кнопка добавляется."
- id: 224892
  author: Никита
  author_email: admin@10kilogramm.ru
  author_url: http://10kilogramm.ru/
  date: '2014-02-18 21:06:09 +0400'
  date_gmt: '2014-02-18 17:06:09 +0400'
  content: Если в списке слишком много элементов, при нажатии на стрелочку отображаются
    сразу все, без полосы прокрутки, а это доставляет немало хлопот если список объёмный.
    Можно ли в данную структуру как-то внедрить полосу прокрутки ?
- id: 224893
  author: SlowProg
  author_email: paperplanesu@rambler.ru
  author_url: http://paperplane.su
  date: '2014-02-18 21:16:30 +0400'
  date_gmt: '2014-02-18 17:16:30 +0400'
  content: "Думаю поможет стиль что-то вроде этого:\r\n\r\n<code>.ui-autocomplete
    {\r\nmax-height: 250px;\r\noverflow-x: scroll;\r\n}<&#47;code>"
- id: 226025
  author: Андрей
  author_email: fai_@mail.ru
  author_url: http://www.pro-dvinem.ru
  date: '2014-03-04 15:24:26 +0400'
  date_gmt: '2014-03-04 11:24:26 +0400'
  content: "Спасибо за отличную статью! Работает список, и поиск тоже.\r\nНо вот вопрос:
    Как обрабатывать события выбора элемента?\r\n\r\nНи один из нижеперечисленных
    ариантов не срабатывает.\r\n\r\n&#47;&#47;$(document).on('change', '#combobox',
    function(){\r\n$('#combobox').change(function(){\r\n\talert($('#combobox').val());\r\n});"
- id: 226028
  author: SlowProg
  author_email: paperplanesu@rambler.ru
  author_url: http://paperplane.su
  date: '2014-03-04 15:45:50 +0400'
  date_gmt: '2014-03-04 11:45:50 +0400'
  content: |-
    После 35ой строки добавьте следующее:

    <code>select.trigger("change");<&#47;code>

    Тогда будет работать код:

    <code>$("#combobox").change(function() {
        alert(this.value);
    });<&#47;code>

    Наверно.
- id: 226033
  author: Андрей
  author_email: fai_@mail.ru
  author_url: http://www.pro-dvinem.ru
  date: '2014-03-04 16:59:02 +0400'
  date_gmt: '2014-03-04 12:59:02 +0400'
  content: да! И не наверное, а точно :) спасибо!!!
- id: 234401
  author: VaneS
  author_email: vanes-xxl@list.ru
  author_url: ''
  date: '2014-06-24 15:58:10 +0400'
  date_gmt: '2014-06-24 11:58:10 +0400'
  content: "Не совсем понятно,куда вставлять \r\n<code>select.trigger(\"change\");<&#47;code>\r\nМожете
    прислать весь код вместе с этой строкой? Вроде вставляю как описали, но у меня
    не работает.\r\nЗаранее большое спасибо!"
- id: 234403
  author: SlowProg
  author_email: paperplanesu@rambler.ru
  author_url: http://paperplane.su
  date: '2014-06-24 16:09:12 +0400'
  date_gmt: '2014-06-24 12:09:12 +0400'
  content: "<code>\r\n(function( $ ) {\r\n    $.widget( \"ui.combobox\", {\r\n        _create:
    function() {\r\n            var self = this,\r\n                select = this.element.hide(),\r\n
    \               selected = select.children( \":selected\" ),\r\n                value
    = selected.val() ? selected.text() : \"\";\r\n            var input = this.input
    = $( \"<input>\" )\r\n                .insertAfter( select )\r\n                .val(
    value )\r\n                .autocomplete({\r\n                    delay: 0,\r\n
    \                   minLength: 0,\r\n                    source: function( request,
    response ) {\r\n                        var matcher = new RegExp( $.ui.autocomplete.escapeRegex(request.term),
    \"i\" );\r\n                        response( select.children( \"option\" ).map(function()
    {\r\n                            var text = $( this ).text();\r\n                            if
    ( this.value && ( !request.term || matcher.test(text) ) )\r\n                                return
    {\r\n                                    label: text.replace(\r\n                                        new
    RegExp(\r\n                                            \"(?![^&;]+;)(?!<[^<>]*)(\"
    +\r\n                                            $.ui.autocomplete.escapeRegex(request.term)
    +\r\n                                            \")(?![^<>]*>)(?![^&;]+;)\",
    \"gi\"\r\n                                        ), \"<strong>$1<&#47;strong>\"
    ),\r\n                                    value: text,\r\n                                    option:
    this\r\n                                };\r\n                        }) );\r\n
    \                   },\r\n                    select: function( event, ui ) {\r\n
    \                       ui.item.option.selected = true;\r\n                        self._trigger(
    \"selected\", event, {\r\n                            item: ui.item.option\r\n
    \                       });\r\n                        select.trigger(\"change\");\r\n
    \                   },\r\n                    change: function( event, ui ) {\r\n
    \                       if ( !ui.item ) {\r\n                            var matcher
    = new RegExp( \"^\" + $.ui.autocomplete.escapeRegex( $(this).val() ) + \"$\",
    \"i\" ),\r\n                                valid = false;\r\n                            select.children(
    \"option\" ).each(function() {\r\n                                if ( $( this
    ).text().match( matcher ) ) {\r\n                                    this.selected
    = valid = true;\r\n                                    return false;\r\n                                }\r\n
    \                           });\r\n                            if ( !valid ) {\r\n
    \                               &#47;&#47; remove invalid value, as it didn't
    match anything\r\n                                $( this ).val( \"\" );\r\n                                select.val(
    \"\" );\r\n                                input.data( \"autocomplete\" ).term
    = \"\";\r\n                                return false;\r\n                            }\r\n
    \                       }\r\n                    }\r\n                })\r\n                .addClass(
    \"ui-widget ui-widget-content ui-corner-left\" );\r\n\r\n            input.data(
    \"autocomplete\" )._renderItem = function( ul, item ) {\r\n                return
    $( \"<li><&#47;li>\" )\r\n                    .data( \"item.autocomplete\", item
    )\r\n                    .append( \"<a>\" + item.label + \"<&#47;a>\" )\r\n                    .appendTo(
    ul );\r\n            };\r\n\r\n            this.button = $( \"<button type='button'>&nbsp;<&#47;button>\"
    )\r\n                .attr( \"tabIndex\", -1 )\r\n                .attr( \"title\",
    \"Show All Items\" )\r\n                .insertAfter( input )\r\n                .button({\r\n
    \                   icons: {\r\n                        primary: \"ui-icon-triangle-1-s\"\r\n
    \                   },\r\n                    text: false\r\n                })\r\n
    \               .removeClass( \"ui-corner-all\" )\r\n                .addClass(
    \"ui-corner-right ui-button-icon\" )\r\n                .click(function() {\r\n
    \                   &#47;&#47; close if already visible\r\n                    if
    ( input.autocomplete( \"widget\" ).is( \":visible\" ) ) {\r\n                        input.autocomplete(
    \"close\" );\r\n                        return;\r\n                    }\r\n\r\n
    \                   &#47;&#47; work around a bug (likely same cause as #5265)\r\n
    \                   $( this ).blur();\r\n\r\n                    &#47;&#47; pass
    empty string as value to search for, displaying all results\r\n                    input.autocomplete(
    \"search\", \"\" );\r\n                    input.focus();\r\n                });\r\n
    \       },\r\n\r\n        destroy: function() {\r\n            this.input.remove();\r\n
    \           this.button.remove();\r\n            this.element.show();\r\n            $.Widget.prototype.destroy.call(
    this );\r\n        }\r\n    });\r\n})( jQuery );\r\n<&#47;code>"
- id: 234832
  author: VaneS
  author_email: vanes-xxl@list.ru
  author_url: ''
  date: '2014-07-01 14:35:40 +0400'
  date_gmt: '2014-07-01 10:35:40 +0400'
  content: Скажите пожалуйста, а можно этот список сделать не активным, на подобие
    обычного списка, присвоив обычному списку атрибут disabled. Заранее большое спасибо!
- id: 234858
  author: SlowProg
  author_email: paperplanesu@rambler.ru
  author_url: http://paperplane.su
  date: '2014-07-02 00:44:49 +0400'
  date_gmt: '2014-07-01 20:44:49 +0400'
  content: "Если нужно на лету уже созданный комбобокс задисейблить, то можно овспользоваться
    таким вот костылём:\n\n<code>$(\"select\").closest(\".ui-widget\").find(\"input,
    button\" ).prop(\"disabled\", true)<&#47;code>\n\nА чтобы через атрибут селекта,
    то наверно придётся переписать чуток код. После 91 строки добавить следующее:\n\n<code>if
    (select.attr('disabled') !== undefined) {\n\tthis.input.attr('disabled', true);\n\tthis.button.attr('disabled',
    true);\n}<&#47;code>\n\nесли у исходного селекта будет disabled то и комбобокс
    будет disabled. Но единственное стили для заблокированных элементов (input и button)
    придётся самому написать. а так по виду они не будут отличаться."
- id: 246847
  author: Валерий
  author_email: femistokl@gmail.com
  author_url: http://www.valerijgerasimov.com/
  date: '2015-02-08 13:52:08 +0300'
  date_gmt: '2015-02-08 09:52:08 +0300'
  content: "Спасибо за отличную статью!\r\nРеализовал. Все работает, но возникла проблема.\r\nУ
    меня в форме несколько селектов и они все стали с автозаполнением, а мне нужно,
    чтобы был только один.\r\nЯ предположил, что он должен привязываться только к
    селекту с id=\"combobox\"\r\nНа самом деле он на него не реагирует. Можно ставить
    любой id. Все равно работает для всех селектов.\r\nЧто посоветуете?\r\nЗаранее
    спасибо!\r\nС уважением!"
- id: 246852
  author: SlowProg
  author_email: paperplanesu@rambler.ru
  author_url: http://paperplane.su
  date: '2015-02-08 14:48:19 +0300'
  date_gmt: '2015-02-08 10:48:19 +0300'
  content: |-
    Если вы вызываете так как написано в статье:

    <code>("select").combobox();<&#47;code>

    то конечно же он будет работать для всех селектов на странице. Если надо запустить только для селекта, где id="combobox", то вызывать надо так:

    <code>("#combobox").combobox();<&#47;code>
- id: 286700
  author: Евгений
  author_email: zhenia3003@mail.ru
  author_url: http://amur.pro
  date: '2016-09-29 12:49:47 +0300'
  date_gmt: '2016-09-29 08:49:47 +0300'
  content: На этом сайте <a href="http:&#47;&#47;amur.pro" rel="nofollow">amur.pro<&#47;a>
    есть окно добавления статей, прикольно было бы ваш выпадающий список использовать
- id: 290878
  author: Павел
  author_email: fedotovps@bk.ru
  author_url: ''
  date: '2016-11-14 16:00:03 +0300'
  date_gmt: '2016-11-14 12:00:03 +0300'
  content: "А как сделать, чтобы выборка осуществлялась не по всей строке, а только
    с начала? Например, ввожу запрос \"ма\", результат:\r\n\r\n-МАтематика\r\n-МАтематический
    анализ\r\n-актерское МАстерство\r\n-шахМАты\r\n\r\nА нужно, чтобы было так:\r\n\r\n-МАтематика\r\n-МАтематический
    анализ\r\n\r\nЗаранее спасибо!"
---
<p><a href="http:&#47;&#47;image.paperplane.su&#47;2011&#47;12&#47;combobox-jquery-ui.png"><img class="alignleft size-medium wp-image-1677" title="Выпадающий список с автозаполнением с помощью jQuery UI" src="http:&#47;&#47;image.paperplane.su&#47;2011&#47;12&#47;combobox-jquery-ui-300x300.png" alt="Выпадающий список с автозаполнением с помощью jQuery UI" width="300" height="300" &#47;><&#47;a>Добрый! Иногда в разработке интерфейса для пользователя бывает очень удобно использовать автозаполнение. Это сразу повышает юзабилити, которое нынче так важно для нас всех. Чтобы не писать велосипеды можно использовать библиотеку <a title="Библиотека jQuery UI" href="http:&#47;&#47;jqueryui.com&#47;" rel="nofollow" target="_blank">jQuery UI<&#47;a> для организации <a title="Автозаполнения в виджетах" href="http:&#47;&#47;jqueryui.com&#47;demos&#47;autocomplete&#47;" rel="nofollow" target="_blank">автозаполнения в различных виджетах<&#47;a>. Это очень просто работает: при заполнении поля появляется список с вариантами ввода, который фильтруется по мере ввода новых символов. Автозаполнение может быть прикреплено к полю поиска, предлагая либо поисковые запросы,&nbsp; либо совпадающие результаты для более быстрой навигации. Но что, если существует фиксированный список, выполненный с помощью тега <em><br />
<select><&#47;em>, где возможность подобной фильтрации поможет пользователю найти нужное значение?</p>
<p>Это так называемый сombobox будет работать как <em><br />
<select><&#47;em>, но помимо этого будет доступна возможность вводить с клавиатуры, как в обычное поле ввода, для фильтрации возможных вариантов. В демках jQuery UI фактически представлен образец реализации <a title="Выпадающий список в автозаполнением" href="http:&#47;&#47;jqueryui.com&#47;demos&#47;autocomplete&#47;#combobox" rel="nofollow" target="_blank">выпадающего списка с автозаполнением<&#47;a>. В этой статье мы будем рассматривать код этого демо, чтобы выяснить, как работает виджет комбобокс и автозаполнение вместе.</p>
<p>Начнем с инициализации HTML разметки:<br />
[cce lang="xml"]<label>Your preferred programming language: <&#47;label></p>
<select>
<option value="">Select one...<&#47;option></p>
<option value="ActionScript">ActionScript<&#47;option></p>
<option value="AppleScript">AppleScript<&#47;option></p>
<option value="Asp">Asp<&#47;option></p>
<option value="BASIC">BASIC<&#47;option></p>
<option value="C">C<&#47;option></p>
<option value="C++">C++<&#47;option></p>
<option value="Clojure">Clojure<&#47;option></p>
<option value="COBOL">COBOL<&#47;option></p>
<option value="ColdFusion">ColdFusion<&#47;option></p>
<option value="Erlang">Erlang<&#47;option></p>
<option value="Fortran">Fortran<&#47;option><br />
<&#47;select>[&#47;cce]<br />
Ничего особенного тут нет, просто <em>label<&#47;em> и <em>select<&#47;em> с несколькими вариантами на выбор. И сам код для использования виджета combobox достаточно прост:<br />
[cce lang="js"]$("select").combobox();[&#47;cce]<br />
Далее давайте посмотрим на код виджета combobox. В начале я дам общее представление показав полный код виджета, а затем мы будем разбирать его по частям шаг за шагом.<br />
[cce lang="js"](function( $ ) {<br />
	$.widget( "ui.combobox", {<br />
		_create: function() {<br />
			var self = this,<br />
				select = this.element.hide(),<br />
				selected = select.children( ":selected" ),<br />
				value = selected.val() ? selected.text() : "";<br />
			var input = this.input = $( "<input>" )<br />
				.insertAfter( select )<br />
				.val( value )<br />
				.autocomplete({<br />
					delay: 0,<br />
					minLength: 0,<br />
					source: function( request, response ) {<br />
						var matcher = new RegExp( $.ui.autocomplete.escapeRegex(request.term), "i" );<br />
						response( select.children( "option" ).map(function() {<br />
							var text = $( this ).text();<br />
							if ( this.value &amp;&amp; ( !request.term || matcher.test(text) ) )<br />
								return {<br />
									label: text.replace(<br />
										new RegExp(<br />
											"(?![^&amp;;]+;)(?!<[^<>]*)(" +<br />
											$.ui.autocomplete.escapeRegex(request.term) +<br />
											")(?![^<>]*>)(?![^&amp;;]+;)", "gi"<br />
										), "<strong>$1<&#47;strong>" ),<br />
									value: text,<br />
									option: this<br />
								};<br />
						}) );<br />
					},<br />
					select: function( event, ui ) {<br />
						ui.item.option.selected = true;<br />
						self._trigger( "selected", event, {<br />
							item: ui.item.option<br />
						});<br />
					},<br />
					change: function( event, ui ) {<br />
						if ( !ui.item ) {<br />
							var matcher = new RegExp( "^" + $.ui.autocomplete.escapeRegex( $(this).val() ) + "$", "i" ),<br />
								valid = false;<br />
							select.children( "option" ).each(function() {<br />
								if ( $( this ).text().match( matcher ) ) {<br />
									this.selected = valid = true;<br />
									return false;<br />
								}<br />
							});<br />
							if ( !valid ) {<br />
								&#47;&#47; remove invalid value, as it didn't match anything<br />
								$( this ).val( "" );<br />
								select.val( "" );<br />
								input.data( "autocomplete" ).term = "";<br />
								return false;<br />
							}<br />
						}<br />
					}<br />
				})<br />
				.addClass( "ui-widget ui-widget-content ui-corner-left" );</p>
<p>			input.data( "autocomplete" )._renderItem = function( ul, item ) {<br />
				return $( "
<li><&#47;li>" )<br />
					.data( "item.autocomplete", item )<br />
					.append( "<a>" + item.label + "<&#47;a>" )<br />
					.appendTo( ul );<br />
			};</p>
<p>			this.button = $( "<button type='button'>&amp;nbsp;<&#47;button>" )<br />
				.attr( "tabIndex", -1 )<br />
				.attr( "title", "Show All Items" )<br />
				.insertAfter( input )<br />
				.button({<br />
					icons: {<br />
						primary: "ui-icon-triangle-1-s"<br />
					},<br />
					text: false<br />
				})<br />
				.removeClass( "ui-corner-all" )<br />
				.addClass( "ui-corner-right ui-button-icon" )<br />
				.click(function() {<br />
					&#47;&#47; close if already visible<br />
					if ( input.autocomplete( "widget" ).is( ":visible" ) ) {<br />
						input.autocomplete( "close" );<br />
						return;<br />
					}</p>
<p>					&#47;&#47; work around a bug (likely same cause as #5265)<br />
					$( this ).blur();</p>
<p>					&#47;&#47; pass empty string as value to search for, displaying all results<br />
					input.autocomplete( "search", "" );<br />
					input.focus();<br />
				});<br />
		},</p>
<p>		destroy: function() {<br />
			this.input.remove();<br />
			this.button.remove();<br />
			this.element.show();<br />
			$.Widget.prototype.destroy.call( this );<br />
		}<br />
	});<br />
})( jQuery );[&#47;cce]</p>
<p>Этот код определяет новый виджет в пространстве имен <em>iu<&#47;em> (не в коем случаи не используйте это для вашего собственного виджета, он зарезервирован для jQuery UI) и добавляет всего два метода <em>_create<&#47;em> и <em>destroy<&#47;em>. Первый метод - это конструктор для виджетов jQuery UI, и он вызывается всего один раз. В версиях до 1.8 он назывался <em>_init<&#47;em>. Теперь этот метод <em>_init<&#47;em> по-прежнему существует, но уже вызывается каждый раз при вызове .combobox() (с входными параметрами или без). Второй метод - это деструктор, но о нем чуть попозже.</p>
<p>Далее идет создание элемента ввода и применения автозаполнения к нему, с помощью данных элемента <em>select<&#47;em>:<br />
[cce lang="js"]var self = this,<br />
	select = this.element.hide(),<br />
	selected = select.children( ":selected" ),<br />
	value = selected.val() ? selected.text() : "";<br />
var input = this.input = $( "<input>" )<br />
	.insertAfter( select )<br />
	.val( value )<br />
	.autocomplete({<br />
		delay: 0,<br />
		minLength: 0,<br />
		source: function( request, response ) {<br />
			&#47;&#47; реализует поиска и фильтрацию данных из select<br />
		},<br />
		select: function( event, ui ) {<br />
			&#47;&#47; реализуется первую часть обновления отобранных из списка<br />
		},<br />
		change: function( event, ui ) {<br />
			&#47;&#47; реализуется вторую часть обновления отобранных из списка<br />
		}<br />
	})<br />
	.addClass( "ui-widget ui-widget-content ui-corner-left" );[&#47;cce]<br />
Все начинается с объявления переменной: <em>var self = this<&#47;em>. Она будет использоваться внутри callback-функции ниже. Переменная <em>select<&#47;em> ссылется на элемент <em>select<&#47;em>, который будет использован для выпадающего списка. Для замены <em>select<&#47;em> на <em>input<&#47;em> первый скрывается (.hide).</p>
<p>Элемент <em>input<&#47;em> создается с нуля, вставляется после элемента <em>select<&#47;em> в DOM и превращается в виджет с автозаполнением. Все три опции автозаполнения настраиваемые:</p>
<ul>
<li><strong>delay<&#47;strong> определяет количество времени ожидания для отображения данных между нажатиями каждой клавиши, здесь установлено равным нулю, так как данные локальные и их ни от куда грузить не надо.<&#47;li>
<li><strong>minLength<&#47;strong> так же установлен в ноль, так что при нажатии клавиши вниз или вверх будет отображаться меню автозаполнения, даже когда ничего не было введено.<&#47;li>
<li><strong>source<&#47;strong> обеспечивает фильтрацию данных перед отображением.<&#47;li><br />
<&#47;ul><br />
Теперь можно поглядеть реализацию <em>source<&#47;em>:<br />
[cce lang="js"]source: function( request, response ) {<br />
	var matcher = new RegExp( $.ui.autocomplete.escapeRegex(request.term), "i" );<br />
	response( select.children("option").map(function() {<br />
		var text = $( this ).text();<br />
		if ( this.value &amp;&amp; ( !request.term || matcher.test(text) ) )<br />
			return {<br />
				label: text.replace(<br />
					new RegExp(<br />
						"(?![^&amp;;]+;)(?!<[^<>]*)(" +<br />
						$.ui.autocomplete.escapeRegex(request.term) +<br />
						")(?![^<>]*>)(?![^&amp;;]+;)", "gi"<br />
					), "<strong>$1<&#47;strong>" ),<br />
				value: text,<br />
				option: this<br />
			};<br />
	}) );<br />
},[&#47;cce]<br />
Тут немного все запутано, но сейчас я все объясню: во-первых, регулярное выражение определяется с помощью вспомогательного метода <em>$ui.autocomplte.escapeRegex<&#47;em> на основе введенного значения. Это регулярное выражение будет использоваться ниже в функции. Аргумент <em>response<&#47;em> - это callback-функция, необходимая для отображения данных, которые является результатом вызова <em>select.children("option").map(callback)<&#47;em>. Это действие находит все элементы <em>option<&#47;em> внутри первоначального <em>select<&#47;em>, затем отображает каждый <em>option<&#47;em> в коллекции элементов с помощью метода <em>map<&#47;em>.</p>
<p>Если поисковый запрос не соответствует ни одну из значений, то будет возвращен <em>undefined<&#47;em>. В противном случае (если нет запроса или есть совпадение), он будет возвращать объект с тремя свойствами:</p>
<ul>
<li><strong>label<&#47;strong>: формируется на основе текста элемента <em>option<&#47;em>, с выделенной жирным соответствующей частью с помощью регулярного выражения.<&#47;li>
<li><strong>value<&#47;strong>: немодифицированный текст элемента <em>option<&#47;em>, который должен быть вставлен в поле ввода текста.<&#47;li>
<li><strong>option<&#47;strong>: сам элемент <em>option<&#47;em> для дальнейших нужд.<&#47;li><br />
<&#47;ul><br />
Свойства <em>label<&#47;em> и <em>value<&#47;em> необходимы виджету автозаполнения, а свойство <em>option<&#47;em> может иметь произвольное имя и используется только локально в этом виджете combobox.</p>
<p>Теперь давайте рассмотрим остальные опции виджета combobox ведь всего их пять. Четвертое и пятое свойства это <em>select<&#47;em> и <em>change<&#47;em> и это события. Реализация <em>select<&#47;em> выглядит следующим образом:<br />
[cce lang="js"]select: function( event, ui ) {<br />
	ui.item.option.selected = true;<br />
	self._trigger( "selected", event, {<br />
		item: ui.item.option<br />
	});<br />
},[&#47;cce]<br />
Аргумент <em>ui.item<&#47;em> ссылается на данные, которые мы предоставили в исходном <em>option<&#47;em>. Через свойство <em>ui.item.option<&#47;em> мы сможем обновить выбранный элемент и запустить событие <em>selected<&#47;em> для дальнейшей кастомизации combobox.</p>
<p>Событие <em>change<&#47;em> используется для случаев, когда не был сделан выбор:<br />
[cce lang="js"]change: function( event, ui ) {<br />
	if ( !ui.item ) {<br />
		var matcher = new RegExp( "^" + $.ui.autocomplete.escapeRegex( $(this).val() ) + "$", "i" ),<br />
			valid = false;<br />
		select.children( "option" ).each(function() {<br />
			if ( $( this ).text().match( matcher ) ) {<br />
				this.selected = valid = true;<br />
				return false;<br />
			}<br />
		});<br />
		if ( !valid ) {<br />
			&#47;&#47; remove invalid value, as it didn't match anything<br />
			$( this ).val( "" );<br />
			select.val( "" );<br />
			input.data( "autocomplete" ).term = "";<br />
			return false;<br />
		}<br />
	}<br />
}[&#47;cce]<br />
Тут введенное значение используется для поиска соответствия при отборе. Если значение не соответствует чему-либо, то оно удаляется (установлено в пустое значение).</p>
<p>Следующий настраиваемый блок - это <em>_renderItem<&#47;em> метод основного автозаполнения. Он необходим для вывода подсветки в каждой строке, таким образом автозаполнение по умолчанию будет экранировать любой HTML.<br />
[cce lang="js"]input.data( "autocomplete" )._renderItem = function( ul, item ) {<br />
	return $( "
<li><&#47;li>" )<br />
		.data( "item.autocomplete", item )<br />
		.append( "<a>" + item.label + "<&#47;a>" )<br />
		.appendTo( ul );<br />
};[&#47;cce]<br />
Теперь необходимо создать кнопку, которая будет открывать полный список возможных вариантов:<br />
[cce lang="js"]this.button = $( "<button type='button'>&amp;nbsp;<&#47;button>" )<br />
	.attr( "tabIndex", -1 )<br />
	.attr( "title", "Show All Items" )<br />
	.insertAfter( input )<br />
	.button({<br />
		icons: {<br />
			primary: "ui-icon-triangle-1-s"<br />
		},<br />
		text: false<br />
	})<br />
	.removeClass( "ui-corner-all" )<br />
	.addClass( "ui-corner-right ui-button-icon" )<br />
	.click(function() {<br />
		&#47;&#47; close if already visible<br />
		if ( input.autocomplete( "widget" ).is( ":visible" ) ) {<br />
			input.autocomplete( "close" );<br />
			return;<br />
		}</p>
<p>		&#47;&#47; work around a bug (likely same cause as #5265)<br />
		$( this ).blur();</p>
<p>		&#47;&#47; pass empty string as value to search for, displaying all results<br />
		input.autocomplete( "search", "" );<br />
		input.focus();<br />
	});[&#47;cce]<br />
Еще один элемент, который создается на лету. Он получает <em>tabIndex = -1<&#47;em>, чтобы вывести его из последовательности переходов, теперь при переходя из combobox с помощью табуляции будет активен другой элемент, а не эта кнопка. Далее устанавливаем <em>title<&#47;em> кнопки, который будет всплывать при наведении. А вызов <em>.button()<&#47;em> с некоторыми опциями вместе с небольшим количеством классов преобразуют обычную кнопку в кнопку-виджет, который будет с закругленными углами справа и стрелкой вниз (если конечно вы будите использовать стили по умолчанию).</p>
<p>Наконец, настраивается событие <em>click<&#47;em> для кнопки: если выпадающий список автозаполнения с возможными вариантами уже виден, то он закрывается, в противном случае метод <em>search<&#47;em> автозаполнения вызывется вместе с пустым значением в качестве аргумента, чтобы найти все элементы, независимо от текущего значения поисковой фразы, что ввели в поле. Как и при вводе с клавиатуры, поле ввода при клике получит фокус, так как фокус на кнопке бесполезен.</p>
<p>А теперь остался последний блок кода, который не вызовет у вас затруднения:<br />
[cce lang="js"]destroy: function() {<br />
	this.input.remove();<br />
	this.button.remove();<br />
	this.element.show();<br />
	$.Widget.prototype.destroy.call( this );<br />
}[&#47;cce]<br />
Этот код полностью уничтожает виджет. Все созданные на лету элементы удаляются, но помимо этого в последней строке кода вы должны вызвать метод <em>destroy<&#47;em> для удаления элемента из базы виджетов.</p>
<div class="aligncenter"><a class="button button_demo" href="http:&#47;&#47;image.paperplane.su&#47;demo&#47;combobox-jquery-ui&#47;index.html" target="_blank">Демо<&#47;a><a class="button button_demo" href="http:&#47;&#47;image.paperplane.su&#47;demo&#47;combobox-jquery-ui&#47;source.zip" target="_blank">Скачать<&#47;a><&#47;div><br />
Вот собственно и все! Теперь вы имеете гибкий и легко настраиваемый выпадающий список с автозаполнением. В случаи чего, вы можете вставить свои CSS классы и настроить отображение виджета, как вам угодно. На сегодня все, удачного вам программирования!</p>
<p>PS: Для тех кому требуется быстрая и качественная <a href="http:&#47;&#47;serenity.su">разработка сайтов<&#47;a> рекомендую обратиться к SERENITY. Там грамотные ребята создадут вам любой сайт, да еще и выдвинут в топ поисковиков.</p>
